起始为ucos任务中printf函数打印浮点错误，但是用int = float*100后正常。

## ucos平台上 printf 输出浮点数据出错

ES丶行者

于 2014-10-28 08:56:33 发布

3819
 收藏 11
文章标签： ucos
版权
自己将UCOS移植到STM32中。在某个任务中用串口输出调试信息：ADC采集的电压值，浮点型数据。

但是在串口观察到的数据为要么是000.00格式，要么是是乱的数字中间添加很多0，甚至还有正负2.000000。调试中将该浮点数放到MDK的WATCH窗口中观察，确实一个符合要求的值，比如：0.435864。


以下是在网上找到的解决办法，就是在要求任务堆栈8字节对齐即可。但是解决问题的过程自己没看懂！先放在这，经常看看。



原因：自己没看明白

我的问题刚开始的时候以为是uCOS任务堆栈太小了，但是开到了4096，还是不行，所以如下添加：
__align(8) static OS_STK AppTaskXXXStk[4096];
就可以了。
正在疑惑中，以下是网络上摘录的，应该是数据对其问题。
昨天跟一个朋友讨论一个问题：

float n1=3.0;
double n2=3.0;
long n3=2000000000;
long n4=1234567890;
printf("%ld %ld %ld %ld\n", n1, n2, n3, n4);


在x86 32位机上执行，输出结果是：0 1074266112 0 1074266112
按照我的理解，float和long在32位机下都占4个字节，即使无法格式化为long进行输出，后面的值也不至于都出问题。


实际里面涉及以下的知识，
1. 把上面的代码反汇编可以看到：
mov    0x80494b4,%eax
mov    %eax,0x18(%esp)
mov    0x80494b0,%eax
mov    %eax,0x14(%esp)
fldl   0x80494a8
fstpl  0xc(%esp)
flds   0x80494a0
fstpl  0x4(%esp)
movl   $0x8048478,(%esp)
call   0x804828c <printf>
我先后把这几个变量定义成了局部和全局的进行了测试，这段是用全局的汇编码。
关键是这几句：
fldl   0x80494a8
fstpl  0xc(%esp)
flds   0x80494a0
fstpl  0x4(%esp)
fldl把浮点地址交给浮点运算寄存器，浮点寄存器是64为精度的，然后fstpl再把值取出按照64位入栈，表象就是按照double类型入栈了。所以虽然内存中单精度浮点数是以4字节存储的，但编译器把它转成了8字节进行处理。
所以最后在栈里的存储就成了
| 00 00 00 00 |<--ESP
| 40 40 00 00 | 
| 00 00 00 00 |
| 40 40 00 00 |
| 49 96 02 d2 |
| 77 35 94 00 |<--EBP


2. printf的处理方式是将输入参数按照字符串进行格式化解析，由于输入的是ld ld ld ld，按照4字节依次进行取值，就得到了上面的结果。


3. float是单精度浮点，遵从IEEE754, S(1)-E(8)-M(23)。3二进制位11，表示为：1.1×2^1 => 指数部分127+1=128-


>10000000，小数部分为1，因此其浮点表示为：
>0 10000000 10000000000000000000000，也就是上面1中看到的0x40400000，打印出的十进制就是1074266112。
>————————————————
>版权声明：本文为CSDN博主「ES丶行者」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
>原文链接：https://blog.csdn.net/xxz1014/article/details/40535245

## 不同架构下字节对齐

# 【硬核贴】无法回避的字节对齐问题，从八个方向深入探讨

[**![img](%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E5%90%88%E9%9B%86.assets/avatar.gif)** 鱼鹰谈单片机](https://www.eet-china.com/mp/u3922552)2021-11-25 11:552139浏览0评论4点赞

![img](%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E5%90%88%E9%9B%86.assets/MBXY-CR-7e2208aaf813fc6e5f2d4e1fb652a5f0.png)

【本文为安富莱电子原创】
  本期的知识点要稍微烧点脑细胞，因为字节对齐问题涉及到的地方太多，且无法规避，必须硬着头皮上。

  下面要说的每个技术点，其实都可以专门开一个帖子说，所以我们这里的讨论，争取言简意赅，并配上官方文档和实验数据，力求有理有据。如果讲解有误的地方，欢迎大家指正，我们主要讨论M0，M0+,  M3，M4和M7内核。



一、引出问题

  字节对齐的含义：4字节对齐的含义就是变量地址对4求余数为0；8字节对齐就是地址对8求余等于0，依次类推，比如：



![img](%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E5%90%88%E9%9B%86.assets/MBXY-CR-3beefd12599dc8c18e5eed78f80281c2.png)



如果让p去访问0x20000001， 0x20000002，0x20000003这都是不对齐访问。



二、背景知识

  对于M3和M4而言，可以直接访问非对齐地址（注意芯片要在这个地址有对应的内存空间),  因为M3和M4是支持的，而M0/M0+/M1是不支持的，不支持的内核芯片，只要非对齐访问就会触发硬件异常。

![img](%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E5%90%88%E9%9B%86.assets/MBXY-CR-92e2d90d9cce479fa866804308617ff6.png)

M7内核也支持非对齐访问，在M7的TRM中描述如下：

![img](%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E5%90%88%E9%9B%86.assets/MBXY-CR-c791518853ca93c2029d387282fdf3c8.png)



三、全局变量对齐问题

  基本上用户定义的变量是几个字节就是几字节对齐，这个比较好理解。
uint8_t定义变量地址要1字节对齐。
uint16_t定义变量地址要2字节对齐。
uint32_t定义变量地址要4字节对齐。
uint64_t定义变量地址要8字节对齐。

指针变量是4字节对齐。



![img](%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E5%90%88%E9%9B%86.assets/MBXY-CR-20c9a247412b5baeab3778d21e92a80f.png)

![img](%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E5%90%88%E9%9B%86.assets/MBXY-CR-f52d96db8d05acc58cc834d9d8e30d7e.png)



四、结构体成员对齐问题

[EE芯视频推荐](https://u.eet-china.com/?xinyu)

[视频：工程师们的必备“神器”-功率分析仪，究竟有多好用？![img](%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E5%90%88%E9%9B%86.assets/video-btn.svg+xml)](https://u.eet-china.com/video/1145?xinyu1)

  首先明白一点，结构体里面的变量是什么类型，此变量的位置就至少要几字节对齐，所以就存在结构体实际占用大小不是这些变量之和。



![img](%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E5%90%88%E9%9B%86.assets/MBXY-CR-6a2ce839dd88b612f607b48fd7a74866.png)

  

  这种定义，info占用了16字节，a单字节对齐，b是两字节对齐，而c要是4字节对齐，从出现b定义完毕后空出来1个字节未被使用。d是8字节对齐，这样就是16字节。而我们切换下变量定义顺序：



![img](%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E5%90%88%E9%9B%86.assets/MBXY-CR-1978250e05df8bc798be8a44c0555844.png)

  

  这种定义就要占用24字节，b占用2字节对齐，c需要4字节对齐，这样就空出来2两个字节未使用，d占用8字节，最后一个a占用了8字节。如果想定义几个变量就几个字节，变量前面加前缀__packed即可。不管是上面那种定义方式，都是占用15个字节。



![img](%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E5%90%88%E9%9B%86.assets/MBXY-CR-14d5fb1e4cc7c48d78e55fa62e93e6c2.png)



五、局部变量对齐

  局部变量使用的是栈空间（除了静态局部变量和编译器优化不使用栈，直接用寄存器做变量空间），也就是大家使用在xxxx.S启动文件开辟的stack空间。
  在M内核里面，局部变量的对齐问题如果研究起来是最烧脑的，这个涉及到AAPCS规约(Procedure Call Standard for the Arm Architecture,  Arm架构的程序调用标准)。


![img](%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E5%90%88%E9%9B%86.assets/MBXY-CR-302bce744416a1742a8043d53cad50cb.png)


 上面这个贴图最重要，仅需理解上面这两条就可以，意思是说，栈地址是全程至少保持4字节对齐的，因为M内核的硬件做了处理，SP最低两个bit，bit0和bit1直接固定为0了。但是在程序调用入口处必须满足8字节对齐，对于C语言，不需要用户去管，编译器都帮我们处理好了，先来个简单的示例压压惊：



![img](%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E5%90%88%E9%9B%86.assets/MBXY-CR-8094d303af41ff1c28a29cb0fe47d998.png)

 

  而汇编文件是需要用户去处理的。以xxx.S启动文件为例，通过伪指令PRESERVE8来保证：



![img](%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E5%90%88%E9%9B%86.assets/MBXY-CR-bbb287aa2eb183100dde6ffe40a5f5cb.png)



 那么问题来了，我们搞个4对齐是不是会出问题，一般情况下也没问题的，但特殊情况下不行，特别调用C库的sprintf和printf函数，直接给你输出个不知所以然的结果来。比如我在H7上做如下测试：



![img](%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E5%90%88%E9%9B%86.assets/MBXY-CR-c1d09a4170c8e1242caec86b2b922f8a.png)

![img](%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E5%90%88%E9%9B%86.assets/MBXY-CR-0c287f2e6ccb22fba2057faf85de2358.png)



输出结果：
![img](%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E5%90%88%E9%9B%86.assets/MBXY-CR-76cc83f673cf81bba75cf109c0962bca.png)



六、中断服务程序的栈对齐问题

先来看两个图：

![img](%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E5%90%88%E9%9B%86.assets/MBXY-CR-3240a1dfcfae517852c3c094f985af47.png)
![img](%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E5%90%88%E9%9B%86.assets/MBXY-CR-443a55bc0ca60e56535045474bd1a9b1.png)


通过这两个图我们了解到：M0/M0+/M7的栈地址是固定8字节对齐，M3/M4的栈地址是对齐是可以通过SCB->CCR寄存器编程的为4字节或者8字节对齐。



  比如我们设置的8字节对齐，那么中断发生的时候，如果SP指针位置在4字节对齐，那么硬件自动插入4字节来保证8字节对齐，之后就是硬件自动入栈的寄存器开始存入栈中。



  另外就是不同的M内核硬件版本，这个地方略有不同，这个大家作为了解即可，早期的内核硬件版本应该没什么人用来做芯片了。



![img](%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E5%90%88%E9%9B%86.assets/MBXY-CR-9e8de048942980e6352f3719cb0abb78.png)

七、硬件浮点对齐问题

  如果使用的是带FPU硬件浮点单元的M内核芯片就要注意对齐访问了，访问单精度浮点数访问一定要4字节对齐，双精度要8字节对齐。比如我们使用支持单精度浮点的M4内核芯片，测试代码如下：



![img](%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E5%90%88%E9%9B%86.assets/MBXY-CR-9234e9af2ed92bce7557251acb2d53f8.png)



MDK直接给你来个不对齐硬件异常：



![img](%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E5%90%88%E9%9B%86.assets/MBXY-CR-33e38968c7248b8939ba663c9f7bae58.png)



八、RTOS任务栈

  RTOS的任务栈涉及到双栈指针问题，SP（R13寄存器）有两个栈指针，MSP主栈指针和PSP进程栈指针。简单的说，我们在中断服务程序里面都是用的MSP，而任务里面用的PSP。优势是方便任务和中断栈空间分别管理，了解了这点知识就够了。

  RTOS任务栈的关键依然是8字节对齐问题，如果仅仅是满足4字节对齐，就会出现我们前面printf和sprintf浮点数或者64bit数据的错误问题，早年各种RTOS移植案例还不是那么发达的时候（现在问题依旧），经常在这个地方入坑，加上硬件浮点寄存器入栈出栈后更是玩不转了。

  比如大家搜索关键词 uCOS printf 或者uCOS 浮点数，一堆的问题，平时不用浮点不知道，一用浮点，各种问题就来了，特别是多任务都使用浮点计算，更是懵。根本原因是底层移植文件的堆栈8字对齐有问题，很多人都是采用的指令__align(8)来设置堆栈对齐问题，其实修改底层port文件才是解决问题的根本。

  为什么会造成这个问题，根本原因依然是前面AAPCS规约的要求，RTOS的移植都有个汇编的port文件，这个port文件的关键是实现任务切换，任务切换的关键就是进入任务前保证PSP是8字节对齐。
![img](%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E5%90%88%E9%9B%86.assets/MBXY-CR-7338f5301c6a02782349d3a21ff78eec.png)



九、DMA对齐问题

  DMA对齐指的是源数据地址和目的数据对齐问题。这个问题最容易出错的地方就是网上倒腾SD卡移植FatFS的SDIO DMA方式。

  大家网上搜关键词FatFS SDIO DMA，也是一瓢的问题，特别是BMP等格式图片显示的时候，这种问题就来了，因为很难保证每次的读取都是4字节对齐的。

  以STM32F4的DMA为例，我们的底层移植无需再单独开一个缓冲做4字节对齐，本质是F4 DMA支持了源地址和目的地址的数据宽度可以不同，但是数据地址必须要跟其数据类型对齐。

  比如使用SDIO DMA从SD卡读取数据，我们就可以设置源地址依然是4字节对齐(外设访问要4字节对齐)，而目的地址设置为字节对齐，就可以方便的解决4字节对齐问题。
![img](%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E5%90%88%E9%9B%86.assets/MBXY-CR-e33af511e9aaf8a9cf2d7f214316dd17.png)

  其实不仅是通用的DMA，像图形加速DMA2D，SDMMC自带的IDMA等都有这种问题。



十、配置MPU Cache造成的对齐问题

  这个问题主要是对于M7内核芯片来说，以STM32H7 TCM以外空间为例：
AXI RAM（0x2400 0000）
SRAM1（0x3000 0000）
SRAM2（0x3002 0000）
SRAM3（0x3004 0000）
SRAM4（0x3800 0000）
SDRAM等做非对齐访问都会有硬件异常，而开启Cache就不会有问题。



  这个问题的关键就是M7的TRM中这句话：意思是如果用户使用MPU将H7的AXI总线下的内存空间配置为Device 或者 Strongly-ordered模式，用户采用非对齐方式访问，将会触发UsageFault：



![img](%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E5%90%88%E9%9B%86.assets/MBXY-CR-eaffcd5c65b20ca161a50d0239e5f3bc.png)



实际测序下，果然会触发这个异常：



![img](%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E5%90%88%E9%9B%86.assets/MBXY-CR-66ffcca2c9f896fefff103f084c4d927.png)



配置内存空间的MPU属性为Device 和 Strongly-ordered以外的属性就可以解决次问题了。

## C语言中字节对齐

C语言字节对齐

深度Java

于 2011-08-29 16:06:57 发布

144551
 收藏 946
分类专栏： C基础 文章标签： c 语言 struct 编译器 数据结构 alignment
版权

C基础
专栏收录该内容
85 篇文章52 订阅
订阅专栏

文章最后本人做了一幅图，一看就明白了，这个问题网上讲的不少，但是都没有把问题说透。

　　一、概念
　　
　　 对齐跟数据在内存中的位置有关。如果一个变量的内存地址正好位于它长度的整数倍，他就被称做自然对齐。比如在32位cpu下，假设一个整型变量的地址为0x00000004，那它就是自然对齐的。
　　
　　二、为什么要字节对齐
　　
　　 需要字节对齐的根本原因在于CPU访问数据的效率问题。假设上面整型变量的地址不是自然对齐，比如为0x00000002，则CPU如果取它的值的话需要访问两次内存，第一次取从0x00000002-0x00000003的一个short，第二次取从0x00000004-0x00000005的一个short然后组合得到所要的数据，如果变量在0x00000003地址上的话则要访问三次内存，第一次为char，第二次为short，第三次为char，然后组合得到整型数据。而如果变量在自然对齐位置上，则只要一次就可以取出数据。一些系统对对齐要求非常严格，比如sparc系统，如果取未对齐的数据会发生错误，举个例：
　　
　　char ch[8];
　　char *p = &ch[1];
　　int i = *(int *)p;
　　
　　
　　运行时会报segment error，而在x86上就不会出现错误，只是效率下降。
　　
　　三、正确处理字节对齐
　　
　　 对于标准数据类型，它的地址只要是它的长度的整数倍就行了，而非标准数据类型按下面的原则对齐：
　　
　　数组 ：按照基本数据类型对齐，第一个对齐了后面的自然也就对齐了。
　　联合 ：按其包含的长度最大的数据类型对齐。
　　结构体： 结构体中每个数据类型都要对齐。
　　比如有如下一个结构体：
　　
　　struct stu{
　　 char sex;
　　 int length;
　　 char name[10];
　　};
　　struct stu my_stu;
　　
　　
　　由于在x86下，GCC默认按4字节对齐，它会在sex后面跟name后面分别填充三个和两个字节使length和整个结构体对齐。于是我们sizeof(my_stu)会得到长度为20，而不是15.
　　
　　四、__attribute__选项
　　
　　我们可以按照自己设定的对齐大小来编译程序，GNU使用__attribute__选项来设置，比如我们想让刚才的结构按一字节对齐，我们可以这样定义结构体
　　
　　struct stu{
　　 char sex;
　　 int length;
　　 char name[10];
　　}__attribute__ ((aligned (1)));
　　
　　struct stu my_stu;
　　
　　
　　则sizeof(my_stu)可以得到大小为15。
　　
　　上面的定义等同于
　　
　　struct stu{
　　 char sex;
　　 int length;
　　 char name[10];
　　}__attribute__ ((packed));
　　struct stu my_stu;
　　
　　
　　__attribute__((packed))得变量或者结构体成员使用最小的对齐方式，即对变量是一字节对齐，对域（field）是位对齐.
　　
　　五、什么时候需要设置对齐
　　
　　 在设计不同CPU下的通信协议时，或者编写硬件驱动程序时寄存器的结构这两个地方都需要按一字节对齐。即使看起来本来就自然对齐的也要使其对齐，以免不同的编译器生成的代码不一样.

 

一、快速理解

1. 什么是字节对齐？

在C语言中，结构是一种复合数据类型，其构成元素既可以是基本数据类型（如int、long、float等）的变量，也可以是一些复合数据类型（如数组、结构、联合等）的数据单元。在结构中，编译器为结构的每个成员按其自然边界（alignment）分配空间。各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构的地址相同。

为了使CPU能够对变量进行快速的访问,变量的起始地址应该具有某些特性,即所谓的”对齐”. 比如4字节的int型,其起始地址应该位于4字节的边界上,即起始地址能够被4整除.

2. 字节对齐有什么作用？

字节对齐的作用不仅是便于cpu快速访问，同时合理的利用字节对齐可以有效地节省存储空间。

对于32位机来说，4字节对齐能够使cpu访问速度提高，比如说一个long类型的变量，如果跨越了4字节边界存储，那么cpu要读取两次，这样效率就低了。但是在32位机中使用1字节或者2字节对齐，反而会使变量访问速度降低。所以这要考虑处理器类型，另外还得考虑编译器的类型。在vc中默认是4字节对齐的，GNU gcc 也是默认4字节对齐。

3. 更改C编译器的缺省字节对齐方式

在缺省情况下，C编译器为每一个变量或是数据单元按其自然对界条件分配空间。一般地，可以通过下面的方法来改变缺省的对界条件：
· 使用伪指令#pragma pack (n)，C编译器将按照n个字节对齐。
· 使用伪指令#pragma pack ()，取消自定义字节对齐方式。

另外，还有如下的一种方式：
· __attribute((aligned (n)))，让所作用的结构成员对齐在n字节自然边界上。如果结构中有成员的长度大于n，则按照最大成员的长度来对齐。
· __attribute__ ((packed))，取消结构在编译过程中的优化对齐，按照实际占用字节数进行对齐。

4. 举例说明

例1

struct test
{
char x1;
short x2;
float x3;
char x4;
};

由于编译器默认情况下会对这个struct作自然边界（有人说“自然对界”我觉得边界更顺口）对齐，结构的第一个成员x1，其偏移地址为0，占据了第1个字节。第二个成员x2为short类型，其起始地址必须2字节对界，因此，编译器在x2和x1之间填充了一个空字节。结构的第三个成员x3和第四个成员x4恰好落在其自然边界地址上，在它们前面不需要额外的填充字节。在test结构中，成员x3要求4字节对界，是该结构所有成员中要求的最大边界单元，因而test结构的自然对界条件为4字节，编译器在成员x4后面填充了3个空字节。整个结构所占据空间为12字节。

例2

#pragma pack(1) //让编译器对这个结构作1字节对齐
struct test
{
char x1;
short x2;
float x3;
char x4;
};
#pragma pack() //取消1字节对齐，恢复为默认4字节对齐

这时候sizeof(struct test)的值为8。

例3

#define GNUC_PACKED __attribute__((packed))
struct PACKED test
{
char x1;
short x2;
float x3;
char x4;
}GNUC_PACKED;

这时候sizeof(struct test)的值仍为8。

二、深入理解

什么是字节对齐,为什么要对齐?
TragicJun 发表于 2006-9-18 9:41:00 现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。
      对齐的作用和原因：各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问一个没有进行对齐的变量的时候会发生错误,那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。
二.字节对齐对程序的影响:

        先让我们看几个例子吧(32bit,x86环境,gcc编译器):
设结构体如下定义：
struct A
{
        int a;
        char b;
        short c;
};
struct B
{
        char b;
        int a;
        short c;
};
现在已知32位机器上各种数据类型的长度如下:
char:1(有符号无符号同)   
short:2(有符号无符号同)   
int:4(有符号无符号同)   
long:4(有符号无符号同)   
float:4        double:8
那么上面两个结构大小如何呢?
结果是:
sizeof(strcut A)值为8
sizeof(struct B)的值却是12

结构体A中包含了4字节长度的int一个，1字节长度的char一个和2字节长度的short型数据一个,B也一样;按理说A,B大小应该都是7字节。
之所以出现上面的结果是因为编译器要对数据成员在空间上进行对齐。上面是按照编译器的默认设置进行对齐的结果,那么我们是不是可以改变编译器的这种默认对齐设置呢,当然可以.例如:
#pragma pack (2) /*指定按2字节对齐*/
struct C
{
        char b;
        int a;
        short c;
};
#pragma pack () /*取消指定对齐，恢复缺省对齐*/
sizeof(struct C)值是8。
修改对齐值为1：
#pragma pack (1) /*指定按1字节对齐*/
struct D
{
        char b;
        int a;
        short c;
};
#pragma pack () /*取消指定对齐，恢复缺省对齐*/
sizeof(struct D)值为7。
后面我们再讲解#pragma pack()的作用.

三.编译器是按照什么样的原则进行对齐的?

        先让我们看四个重要的基本概念：


1.数据类型自身的对齐值：
      对于char型数据，其自身对齐值为1，对于short型为2，对于int,float,double类型，其自身对齐值为4，单位字节。
2.结构体或者类的自身对齐值：其成员中自身对齐值最大的那个值。
3.指定对齐值：#pragma pack (value)时的指定对齐值value。
4.数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中小的那个值。
有了这些值，我们就可以很方便的来讨论具体数据结构的成员和其自身的对齐方式。有效对齐值N是最终用来决定数据存放地址方式的值，最重要。有效对齐N，就是表示“对齐在N上”，也就是说该数据的"存放起始地址%N=0".而数据结构中的数据变量都是按定义的先后顺序来排放的。第一个数据变量的起始地址就是数据结构的起始地址。结构体的成员变量要对齐排放，结构体本身也要根据自身的有效对齐值圆整(就是结构体成员变量占用总长度需要是对结构体有效对齐值的整数倍，结合下面例子理解)。这样就不能理解上面的几个例子的值了。
例子分析：
分析例子B；
struct B
{
        char b;
        int a;
        short c;
};
假设B从地址空间0x0000开始排放。该例子中没有定义指定对齐值，在笔者环境下，该值默认为4。第一个成员变量b的自身对齐值是1，比指定或者默认指定对齐值4小，所以其有效对齐值为1，所以其存放地址0x0000符合0x0000%1=0.第二个成员变量a，其自身对齐值为4，所以有效对齐值也为4，所以只能存放在起始地址为0x0004到0x0007这四个连续的字节空间中，复核0x0004%4=0,且紧靠第一个变量。第三个变量c,自身对齐值为2，所以有效对齐值也是2，可以存放在0x0008到0x0009这两个字节空间中，符合0x0008%2=0。所以从0x0000到0x0009存放的都是B内容。再看数据结构B的自身对齐值为其变量中最大对齐值(这里是b）所以就是4，所以结构体的有效对齐值也是4。根据结构体圆整的要求，0x0009到0x0000=10字节，（10＋2）％4＝0。所以0x0000A到0x000B也为结构体B所占用。故B从0x0000到0x000B共有12个字节,sizeof(struct B)=12;其实如果就这一个就来说它已将满足字节对齐了,因为它的起始地址是0,因此肯定是对齐的,之所以在后面补充2个字节,是因为编译器为了实现结构数组的存取效率,试想如果我们定义了一个结构B的数组,那么第一个结构起始地址是0没有问题,但是第二个结构呢?按照数组的定义,数组中所有元素都是紧挨着的,如果我们不把结构的大小补充为4的整数倍,那么下一个结构的起始地址将是0x0000A,这显然不能满足结构的地址对齐了,因此我们要把结构补充成有效对齐大小的整数倍.其实诸如:对于char型数据，其自身对齐值为1，对于short型为2，对于int,float,double类型，其自身对齐值为4，这些已有类型的自身对齐值也是基于数组考虑的,只是因为这些类型的长度已知了,所以他们的自身对齐值也就已知了.
同理,分析上面例子C：
#pragma pack (2) /*指定按2字节对齐*/
struct C
{
        char b;
        int a;
        short c;
};
#pragma pack () /*取消指定对齐，恢复缺省对齐*/
第一个变量b的自身对齐值为1，指定对齐值为2，所以，其有效对齐值为1，假设C从0x0000开始，那么b存放在0x0000，符合0x0000%1=0;第二个变量，自身对齐值为4，指定对齐值为2，所以有效对齐值为2，所以顺序存放在0x0002、0x0003、0x0004、0x0005四个连续字节中，符合0x0002%2=0。第三个变量c的自身对齐值为2，所以有效对齐值为2，顺序存放
在0x0006、0x0007中，符合0x0006%2=0。所以从0x0000到0x00007共八字节存放的是C的变量。又C的自身对齐值为4，所以C的有效对齐值为2。又8%2=0,C只占用0x0000到0x0007的八个字节。所以sizeof(struct C)=8.

四.如何修改编译器的默认对齐值?

1.在VC IDE中，可以这样修改：[Project]|[Settings],c/c++选项卡Category的Code Generation选项的Struct Member Alignment中修改，默认是8字节。
2.在编码时，可以这样动态修改：#pragma pack .注意:是pragma而不是progma.

五.针对字节对齐,我们在编程中如何考虑?
        如果在编程的时候要考虑节约空间的话,那么我们只需要假定结构的首地址是0,然后各个变量按照上面的原则进行排列即可,基本的原则就是把结构中的变量按照类型大小从小到大声明,尽量减少中间的填补空间.还有一种就是为了以空间换取时间的效率,我们显示的进行填补空间进行对齐,比如:有一种使用空间换时间做法是显式的插入reserved成员：
             struct A{
               char a;
               char reserved[3];//使用空间换时间
               int b;
}

reserved成员对我们的程序没有什么意义,它只是起到填补空间以达到字节对齐的目的,当然即使不加这个成员通常编译器也会给我们自动填补对齐,我们自己加上它只是起到显式的提醒作用.

六.字节对齐可能带来的隐患:

        代码中关于对齐的隐患，很多是隐式的。比如在强制类型转换的时候。例如：
unsigned int i = 0x12345678;
unsigned char *p=NULL;
unsigned short *p1=NULL;

p=&i;
*p=0x00;
p1=(unsigned short *)(p+1);
*p1=0x0000;
最后两句代码，从奇数边界去访问unsignedshort型变量，显然不符合对齐的规定。
在x86上，类似的操作只会影响效率，但是在MIPS或者sparc上，可能就是一个error,因为它们要求必须字节对齐.

七.如何查找与字节对齐方面的问题:

如果出现对齐或者赋值问题首先查看
1. 编译器的big little端设置
2. 看这种体系本身是否支持非对齐访问
3. 如果支持看设置了对齐与否,如果没有则看访问时需要加某些特殊的修饰来标志其特殊访问操作

举例：

#include <stdio.h>
main()
{
struct A {
    int a;
    char b;
    short c;
};

struct B {
    char b;
    int a;
    short c;
};

#pragma pack (2) /*指定按2字节对齐*/
struct C {
    char b;
    int a;
    short c;
};
#pragma pack () /*取消指定对齐，恢复缺省对齐*/

 

#pragma pack (1) /*指定按1字节对齐*/
struct D {
    char b;
    int a;
    short c;
};
#pragma pack ()/*取消指定对齐，恢复缺省对齐*/

int s1=sizeof(struct A);
int s2=sizeof(struct B);
int s3=sizeof(struct C);
int s4=sizeof(struct D);
printf("%d\n",s1);
printf("%d\n",s2);
printf("%d\n",s3);
printf("%d\n",s4);
}

输出：

8

12

8

7

 

修改代码：

struct A {
   // int a;
    char b;
    short c;
};

struct B {
    char b;
   // int a;
    short c;
};

输出：

4

4

输出都是4，说明之前的int影响对齐！

![0_1314609020rbP8](%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E5%90%88%E9%9B%86.assets/0_1314609020rbP8.jpg)

看图就明白了
————————————————
版权声明：本文为CSDN博主「深度Java」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/21aspnet/article/details/6729724