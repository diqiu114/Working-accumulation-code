# C语言超详细讲解函数栈帧的创建和销毁

 更新时间：2022年05月05日 15:37:29  作者：野猪佩奇`  

我们知道c语言中函数都是被调用的，main函数里面能调用其他函数，其实main函数也是被别的函数调用的，下面通过本文给大家分享c语言函数栈帧的创建和销毁过程，一起看看吧



**+**

##### 目录



## 1、本节目标

C语言绝命七连问，你能回答出几个？

- 局部变量是如何创建的？
- 为什么局部变量不初始化其内容是随机的？
- 有些时候屏幕上输出的"烫烫烫"是怎么来的？
- 函数调用时参数时如何传递的？传参的顺序是怎样的？
- 函数的形参和实参的关系是什么？
- 函数的返回值是如何带回的？
- 函数是怎样在栈区上开辟和释放空间的？

想要对上面的这六个问题做出准确深入的回答，我们需要学习函数栈帧的创建和销毁相关知识，在正式进入函数栈帧之前，我们还需要了解一些相关的寄存器和汇编指令。



## 2、相关寄存器

- eax：通用寄存器，保留临时数据，常用于返回值。
- ebx：通用寄存器，保留临时数据。
- ebp：栈底寄存器，用来记录栈底的地址。
- esp：栈顶寄存器，用来记录栈顶的地址。
- eip：指令寄存器，保存当前指令的下一条指令的地址。



## 3、相关汇编指令

- mov：数据转移指令。
- sub：减法命令。
- add：加法命令。
- push：数据入栈，同时esp栈顶寄存器也要发生改变。
- pop：数据弹出至指定位置，同时esp栈顶寄存器也要发生改变。
- call：函数调用，1. 压入返回地址 2. 转入目标函数。
- jump：通过修改eip，转入目标函数，进行调用。
- lea：传递地址指令，用于加载有效地址。
- ret：恢复返回地址，压入eip，类似pop eip命令。



## 4、什么是函数栈帧

函数栈帧（stack frame）就是函数调用过程中在程序的调用栈（call stack）所开辟的空间，这些空间是用来存放：

- 函数参数和函数返回值。
- 临时变量（包括函数的非静态的局部变量以及编译器自动生产的其他临时变量）。
- 保存上下文信息（包括在函数调用前后需要保持不变的寄存器）。

同时，每一次函数调用，编译器都会为该函数分配一块空间，而这块空间就被称为这个函数的函数栈帧；并且，这块空间是由两个寄存器来维护的：esp寄存器（记录栈顶的地址）和ebp寄存器（记录栈底的地址）。

![img](c%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A7%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81.assets/2022050515250651.png)



## 5、什么是调用堆栈

函数调用堆栈是反馈函数调用逻辑的。我们以main函数的调用为例：

![img](c%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A7%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81.assets/2022050515250652.png)

我们可以看到，mainCRTStartup调用__scrt_common_main，__scrt_common_main调用__scrt_common_main_seh，__scrt_common_main_seh调用_SCRT_STARTUP_MAIN，_SCRT_STARTUP_MAINmain，main调用Add。



## 6、函数栈帧的创建和销毁

我们以一段程序为例讲解函数栈帧：（注意： 函数栈帧的创建和销毁过程，在不同的编译器上实现的方法和细节会有所差异，一般来说，越新的编译器对函数栈帧的封装就越严密，本次演示以VS2019为例。）

演示代码

```
#include<stdio.h>``int` `Add(``int` `x, ``int` `y)``{``  ``int` `z = 0;``  ``z = x + y;``  ``return` `z;``}``int` `main()``{``  ``int` `a = 3;``  ``int` `b = 5;``  ``int` `ret = 0;``  ``ret = Add(a, b);``  ``printf``(``"%d"``, ret);``  ``return` `0;``}
```



### (1)、main函数栈帧的创建与初始化

![img](c%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A7%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81.assets/2022050515250653.png)

![img](c%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A7%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81.assets/2022050515250654.png)

![img](c%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A7%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81.assets/2022050515250655.png)



### (2)、main函数的核心代码

![img](c%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A7%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81.assets/2022050515250656.png)

![img](c%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A7%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81.assets/2022050515250757.png)

![img](c%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A7%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81.assets/2022050515250758.png)



### (3)、Add函数的调用过程

F11进入Add函数内部，观察Add函数的反汇编代码

![img](c%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A7%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81.assets/2022050515250759.png)

代码执行到Add函数的时候，就要开始创建Add函数的栈帧空间了。

在Add函数中创建栈帧的方法和在main函数中是相似的，在栈帧空间的大小上略有差异而已。

\1. 将main函数的 ebp 压栈。

\2. 计算新的 ebp 和 esp。

\3. 将 ebx ， esi ， edi 寄存器的值保存。

\4. 计算求和，在计算求和的时候，我们是通过 ebp 中的地址进行偏移访问 到了函数调用前压栈进去的参数，这就是形参访问。

\5. 将求出的和放在 eax 寄存器中准备带回。

![img](c%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A7%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81.assets/2022050515250760.png)

![img](c%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A7%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81.assets/2022050515250761.png)



### (4)、Add函数栈帧的销毁

当函数调用要结束返回的时候，前面创建的函数栈帧也开始销毁，具体销毁过程如下：

![img](c%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A7%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81.assets/2022050515250762.png)

![img](c%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A7%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81.assets/2022050515250863.png)

![img](c%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A7%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81.assets/2022050515250864.png)



### (5)、调用完成

调用完Add函数，回到main函数的时候，继续往下执行，可以看到：

![img](c%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A7%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81.assets/2022050515250865.png)

00BE185D add esp,8 esp直接+8，相当于跳过了main函数中压栈的a’和b’。

00BE1860 mov dword ptr [ebp-20h],eax 将eax中值，存档到ebp-0x20的地址处，其实就是存储到main函数中ret变量中，而此时eax中就是Add函数中计算的x和y的和，可以看出来，本次函数的返回值是由eax寄存器带回来的。程序是在函数调用返回之后，在eax中去读取返回值的。



## 7、对开篇问题的解答

当我们完整的了解了函数栈帧创建和销毁的过程后，我们就可以回答开篇提到的问题了：

1.局部变量是如何创建的？

局部变量的创建是在局部变量所在的函数的栈帧创建完成并初始化后，然后在该栈帧内为局部变量分配空间的。

2.为什么局部变量不初始化其内容是随机的？

因为编译器在创建函数栈帧后会在栈帧空间里面放入一个值，而这个值是随机的。

3.有些时候屏幕上输出的"烫烫烫"是怎么来的？

因为main函数调用时，在栈区开辟的空间的其中每一个字节都被初始化为0xCC，而如果我们定义的是一个未初始化的数组，且这个数组恰好在这块空间上创建，因为0xCCCC（两个连续排列的0xCC）的汉字编码是“烫”，所以屏幕上输出的就是烫烫烫。

4.函数调用时参数时如何传递的？传参的顺序是怎样的？

我们在调用函数之前，就会在栈顶上从右向左依次压入需要传递的参数，在创建好被调函数的函数栈帧后通过指针的偏移量来使用传递过去的参数，而不是在被调函数的函数栈帧内创建形参。

5.函数的形参和实参的关系是什么？

形参是实参的一份临时拷贝，二者的存储位置不同，形参的改变不会影响实参。

6.函数的返回值是如何带回的？

函数的返回值通过eax寄存器带回。

7.函数是怎样在栈区上开辟和释放空间的？

函数通过改变esp和edp的指向来创建和销毁空间，空间销毁并不会清除该空间中的数据，下一次使用该空间时新数据直接覆盖原数据即可。

到此这篇关于C语言超详细讲解函数栈帧的创建和销毁的文章就介绍到这了,更多相关C语言函数栈帧内容请搜索脚本之家以前的文章或继续浏览下面的相关文章希望大家以后多多支持脚本之家！

**您可能感兴趣的文章:**

- [c语言函数栈帧的创建和销毁过程详解](https://www.jb51.net/article/219358.htm)
- [C语言函数栈帧的创建和销毁详解](https://www.jb51.net/article/237622.htm)
- [C语言函数栈帧的创建和销毁介绍](https://www.jb51.net/article/232236.htm)
- [C语言函数栈帧的创建与销毁详解](https://www.jb51.net/article/238195.htm)
- [C语言中函数栈帧的创建和销毁的深层分析](https://www.jb51.net/article/244052.htm)
- [C语言详尽图解函数栈帧的创建和销毁实现](https://www.jb51.net/article/247028.htm)
- [C语言函数栈帧的创建与销毁原理图解](https://www.jb51.net/article/248668.htm)
- [C语言函数栈帧的创建与销毁详解](https://www.jb51.net/article/262135.htm)