# 资料如下：

# 一、进程

- 进程是程序一次动态执行的过程，是程序运行的基本单位。
- 每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。
- 进程占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、页表、文件句柄等）比较大，但相对比较稳定安全。协程切换和协程切换

***\*总结：保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体，这个内存体有自己独立的地址空间，有自己的堆，上级挂靠单位是操作系统。操作系统会以进程为单位，分配系统资源\**\**（CPU时间片、内存等资源）\**\**，进程是资源分配的最小单位。\****

# 二、线程

- 线程又叫做轻量级进程，是CPU调度的最小单位。
- 线程从属于进程，是程序的实际执行者。一个进程至少包含一个主线程，也可以有更多的子线程。
- 多个线程共享所属进程的资源，同时线程也拥有自己的专属资源。
- 程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。

***\*总结：线程从属于进程，是程序的实际执行者。一个进程可以有多个线程，最少有一个线程，但一个线程只能有一个进程。\****

![img](%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B.assets/69672e3d2a04433e8370d65c1a842b72.png)

# 三、协程

- **协程是一种用户态的轻量级线程，协程的调度完全由用户控制**。
- 一个线程可以拥有多个协程，协程不是被操作系统内核所管理，而完全是由程序所控制。
- 与其让操作系统调度，不如我自己来，这就是协程

***\*总结：协程最主要的作用是在单线程的条件下实现并发的效果，但实际上还是串行的(像\**\**\**yield\**\**\**一样)一个线程可以拥有多个协程，协程不是被操作系统内核所管理，而完全是由程序所控制。\****

![img](%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B.assets/1dc26b30909e4ce88bfbd19438ecceae.png)





# 我的理解如下

可能是处于安全的因素考虑，让进程崩了不至于让整个系统挂掉，所以给进程分配了独立的内存空间，在抽象层面和独立的硬件内存硅片一样，而线程就运行在这各独立的内存里



**线程切换为什么比进程快：**

进程切换会多页表切换（也就是记录了空间内存信息），这里比较慢；

线程切换仅仅是上下文切换



**关于协程：**

就是用户控制的线程，用户决定让出





**关于协程阻塞导致所有协程阻塞：**

总结：协程阻塞后，相当于用户没有让出，协程库无法产生调度

文章如下：

作者：望山
链接：https://www.zhihu.com/question/528076353/answer/2744859095
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



近期我已经反复强调了好几遍，在现代主流操作系统Windows和Linux上，不存在操作系统先选择要运行的进程、再从这个进程里面选择要运行的线程这种两层次调度机制。在Linux上，CPU调度单位就是进程，线程只是一种特殊进程，跟其他进程是平等的；而Windows上调度单位就是线程（也就是操作系统原理里面讲的进程，Windows的process其实是与CPU调度无关的别的的东西）。所以为了文字清晰，下面我会统一用进程这个名词来表述操作系统的CPU调度单位。用户级线程这个名词，近年通常被叫做协程，下面我也用协程来称呼它，简便一些。

题主问题是，协程被阻塞的时候为何不去调出另一个协程来运行？这个提问暗含着一个错误前提，就是当协程被阻塞的时候，它所属的进程后台还有什么协程管理代码在悄悄地运行着，可以去调度另一个协程。事实上协程被阻塞时，进程里的用户态代码一条指令也进行不下去，不可能跳转到协程库的管理代码，去寻找另一个可以运行的协程。

协程库确实有它的调度机制，但并不是阻塞了以后才进行调度，而是当协程预感到自己将要被阻塞的时候（或者因为其他原因不想继续霸占运行权的时候），主动向协程库的管理模块报告，说我要让位了，你让别人来吧。协程库的管理模块是被动的，收到请求才会工作，它不会主动监视每个协程的状态，也不会主动进行协程切换。

比方说，如果某个协程要等待一个不知何时到来的网络数据包，它就会在启动了异步网络接收操作之后，主动把运行权转让出去。假如在这里你不用异步io，而是用了个可能发生阻塞的同步读操作，那么协程就被阻塞在网络库函数或者操作系统内部了，根本没有机会去调用协程库的管理功能。

我有个感觉，题主可能误以为CPU调度机制是进程、系统级线程、协程的三级层次，所以疑惑为什么当一个协程被阻塞的时候，为何不是只有它所在的系统级线程被阻塞，操作系统明明可以调度同一个进程下的其他线程来运行，为何书上说整个进程都被阻塞了呢？我猜这本书可能比较老了，是在只有进程和用户级线程的年代写的，当年它的说法是对的，因为当年没有系统级线程这个东西。现在这个说法原则上也是对的，只是要把名词重新定义一下，现在真实操作系统产品上的系统级线程才是操作系统理论里说的进程。